'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var net = require('net');
var tls = require('tls');
var events = require('events');
var fs = require('fs');
var crypto = require('crypto');
var path = require('path');

function _interopNamespace(e) {
    if (e && e.__esModule) return e;
    var n = Object.create(null);
    if (e) {
        Object.keys(e).forEach(function (k) {
            if (k !== 'default') {
                var d = Object.getOwnPropertyDescriptor(e, k);
                Object.defineProperty(n, k, d.get ? d : {
                    enumerable: true,
                    get: function () { return e[k]; }
                });
            }
        });
    }
    n["default"] = e;
    return Object.freeze(n);
}

var fs__namespace = /*#__PURE__*/_interopNamespace(fs);
var crypto__namespace = /*#__PURE__*/_interopNamespace(crypto);
var path__namespace = /*#__PURE__*/_interopNamespace(path);

class FastMailer extends events.EventEmitter {
    constructor(config) {
        var _a, _b, _c, _d, _e, _f, _g;
        super();
        // Determine if port requires secure connection
        const securePort = config.port === 465;
        this.config = {
            ...config,
            // Number of retry attempts for failed email sends
            retryAttempts: config.retryAttempts || 3,
            // Socket timeout in milliseconds
            timeout: config.timeout || 5000,
            // Whether to keep connections alive between sends
            keepAlive: config.keepAlive || false,
            // Maximum number of simultaneous connections
            poolSize: config.poolSize || 5,
            // Force secure true if using secure port
            secure: securePort ? true : config.secure,
            // Rate limiting configuration with more secure defaults
            rateLimiting: {
                perRecipient: true,
                burstLimit: 5,
                cooldownPeriod: 1000,
                banDuration: 7200000,
                maxConsecutiveFailures: 3,
                failureCooldown: 300000,
                maxRapidAttempts: 10,
                rapidPeriod: 10000,
                ...config.rateLimiting
            },
            // Logging configuration
            logging: {
                level: ((_a = config.logging) === null || _a === void 0 ? void 0 : _a.level) || 'info',
                format: ((_b = config.logging) === null || _b === void 0 ? void 0 : _b.format) || 'json',
                customFields: ((_c = config.logging) === null || _c === void 0 ? void 0 : _c.customFields) || [],
                destination: (_d = config.logging) === null || _d === void 0 ? void 0 : _d.destination
            }
        };
        if (!this.config.from) {
            throw new Error('From address is required in config');
        }
        // Log warning if secure port but secure not set
        if (securePort && !config.secure) {
            console.warn('Port 465 requires secure connection. Forcing secure: true');
        }
        // Setup logging
        if ((_e = this.config.logging) === null || _e === void 0 ? void 0 : _e.destination) {
            try {
                this.logFilePath = path__namespace.isAbsolute(this.config.logging.destination) ?
                    this.config.logging.destination :
                    path__namespace.join(process.cwd(), this.config.logging.destination);
                const logDir = path__namespace.dirname(this.logFilePath);
                if (!fs__namespace.existsSync(logDir)) {
                    fs__namespace.mkdirSync(logDir, { recursive: true });
                }
                fs__namespace.appendFileSync(this.logFilePath, '');
            }
            catch (error) {
                this.logFilePath = undefined;
                console.warn('Failed to setup log file:', error);
            }
        }
        this.connectionPool = new Map();
        this.rateLimits = new Map();
        this.metrics = {
            emails_total: 0,
            emails_successful: 0,
            emails_failed: 0,
            failed_emails: [],
            email_send_duration_seconds: {
                sum: 0,
                count: 0,
                avg: 0,
                max: 0,
                min: Number.MAX_VALUE,
                buckets: {
                    '0.1': 0,
                    '0.5': 0,
                    '1': 0,
                    '2': 0,
                    '5': 0
                }
            },
            email_send_rate: 0,
            last_email_status: 'none',
            last_email_timestamp: Date.now(),
            active_connections: 0,
            connection_errors: 0,
            rate_limit_exceeded_total: 0,
            current_rate_limit_window: {
                count: 0,
                remaining: ((_f = this.config.rateLimiting) === null || _f === void 0 ? void 0 : _f.burstLimit) || 5,
                reset_time: Date.now() + (((_g = this.config.rateLimiting) === null || _g === void 0 ? void 0 : _g.cooldownPeriod) || 1000)
            },
            errors_by_type: {
                connection: 0,
                authentication: 0,
                rate_limit: 0,
                validation: 0,
                timeout: 0,
                attachment: 0,
                command: 0,
                unknown: 0
            },
            consecutive_failures: 0,
            last_error_timestamp: null,
            banned_recipients_count: 0,
            total_retry_attempts: 0,
            successful_retries: 0,
            failure_details: {
                last_error: null,
                error_count_by_recipient: new Map(),
                most_common_errors: [],
                avg_failures_per_recipient: 0
            }
        };
        this.socket = null;
    }
    validateEmail(email) {
        // More strict email validation regex
        const emailRegex = /^[a-zA-Z0-9](?:[a-zA-Z0-9!#$%&'*+\-/=?^_`{|}~]*[a-zA-Z0-9])?(?:\.[a-zA-Z0-9](?:[a-zA-Z0-9!#$%&'*+\-/=?^_`{|}~]*[a-zA-Z0-9])?)*@[a-zA-Z0-9](?:[a-zA-Z0-9-]*[a-zA-Z0-9])?(?:\.[a-zA-Z0-9](?:[a-zA-Z0-9-]*[a-zA-Z0-9])?)+$/;
        // Basic checks first
        if (!email || email.includes(' ') || email.includes('..') || email.startsWith('.') || email.endsWith('.') || email.includes('@@')) {
            return false;
        }
        return emailRegex.test(email);
    }
    checkRateLimit(recipient) {
        var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o, _p, _q, _r, _s, _t, _u, _v, _w;
        const now = Date.now();
        let recipientLimits = this.rateLimits.get(recipient);
        if (!recipientLimits) {
            recipientLimits = {
                count: 0,
                lastReset: now,
                banned: false,
                banExpiry: 0,
                consecutiveFailures: 0,
                lastFailure: 0,
                rapidAttempts: 0,
                lastAttempt: now
            };
            this.rateLimits.set(recipient, recipientLimits);
        }
        // Check rapid sending attempts
        const rapidPeriod = ((_a = this.config.rateLimiting) === null || _a === void 0 ? void 0 : _a.rapidPeriod) || 10000; // 10 seconds
        if (now - recipientLimits.lastAttempt < rapidPeriod) {
            recipientLimits.rapidAttempts++;
            if (recipientLimits.rapidAttempts >= (((_b = this.config.rateLimiting) === null || _b === void 0 ? void 0 : _b.maxRapidAttempts) || 10)) {
                recipientLimits.banned = true;
                recipientLimits.banExpiry = now + (((_c = this.config.rateLimiting) === null || _c === void 0 ? void 0 : _c.banDuration) || 7200000);
                this.metrics.banned_recipients_count++;
                this.writeLog('debug', {
                    recipient,
                    event: 'banned',
                    reason: 'rapid_attempts',
                    attempts: recipientLimits.rapidAttempts,
                    period: rapidPeriod,
                    message: 'Too many rapid sending attempts'
                });
                throw {
                    code: 'ERATELIMIT',
                    message: 'Too many rapid sending attempts',
                    details: {
                        type: 'rate_limit_error',
                        context: {
                            recipient,
                            attempts: recipientLimits.rapidAttempts,
                            period: rapidPeriod
                        },
                        timestamp: new Date().toISOString()
                    }
                };
            }
        }
        else {
            recipientLimits.rapidAttempts = 1;
        }
        recipientLimits.lastAttempt = now;
        // Check if currently banned
        if (recipientLimits.banned) {
            if (now < recipientLimits.banExpiry) {
                this.metrics.last_email_status = 'failure';
                this.metrics.errors_by_type.rate_limit++;
                this.writeLog('debug', {
                    recipient,
                    event: 'banned',
                    banExpiry: new Date(recipientLimits.banExpiry).toISOString(),
                    consecutiveFailures: recipientLimits.consecutiveFailures,
                    message: 'Recipient is temporarily banned due to rate limit violations or consecutive failures'
                });
                throw {
                    code: 'ERATELIMIT',
                    message: 'Recipient is temporarily banned due to rate limit violations or consecutive failures',
                    details: {
                        type: 'rate_limit_error',
                        context: {
                            recipient,
                            banExpiry: new Date(recipientLimits.banExpiry).toISOString(),
                            consecutiveFailures: recipientLimits.consecutiveFailures
                        },
                        timestamp: new Date().toISOString()
                    }
                };
            }
            else {
                // Ban expired, reset all limits
                recipientLimits.banned = false;
                recipientLimits.count = 0;
                recipientLimits.lastReset = now;
                recipientLimits.consecutiveFailures = 0;
                recipientLimits.rapidAttempts = 0;
                this.metrics.banned_recipients_count--;
            }
        }
        // Check consecutive failures
        if (recipientLimits.consecutiveFailures >= ((_e = (_d = this.config.rateLimiting) === null || _d === void 0 ? void 0 : _d.maxConsecutiveFailures) !== null && _e !== void 0 ? _e : 3)) {
            const failureCooldown = (_g = (_f = this.config.rateLimiting) === null || _f === void 0 ? void 0 : _f.failureCooldown) !== null && _g !== void 0 ? _g : 300000;
            if (now - recipientLimits.lastFailure < failureCooldown) {
                recipientLimits.banned = true;
                recipientLimits.banExpiry = now + ((_j = (_h = this.config.rateLimiting) === null || _h === void 0 ? void 0 : _h.banDuration) !== null && _j !== void 0 ? _j : 7200000);
                this.metrics.last_email_status = 'failure';
                this.metrics.errors_by_type.rate_limit++;
                this.metrics.banned_recipients_count++;
                this.writeLog('debug', {
                    recipient,
                    event: 'banned',
                    consecutiveFailures: recipientLimits.consecutiveFailures,
                    failureCooldown,
                    message: 'Too many consecutive failures for recipient'
                });
                throw {
                    code: 'ERATELIMIT',
                    message: 'Too many consecutive failures for recipient',
                    details: {
                        type: 'rate_limit_error',
                        context: {
                            recipient,
                            consecutiveFailures: recipientLimits.consecutiveFailures,
                            failureCooldown
                        },
                        timestamp: new Date().toISOString()
                    }
                };
            }
            else {
                // Reset consecutive failures after cooldown
                recipientLimits.consecutiveFailures = 0;
            }
        }
        // Reset count if cooldown period has passed
        if (now - recipientLimits.lastReset > ((_l = (_k = this.config.rateLimiting) === null || _k === void 0 ? void 0 : _k.cooldownPeriod) !== null && _l !== void 0 ? _l : 1000)) {
            recipientLimits.count = 0;
            recipientLimits.lastReset = now;
        }
        // Check burst limit
        if (recipientLimits.count >= ((_o = (_m = this.config.rateLimiting) === null || _m === void 0 ? void 0 : _m.burstLimit) !== null && _o !== void 0 ? _o : 5)) {
            this.metrics.rate_limit_exceeded_total++;
            this.metrics.last_email_status = 'failure';
            this.metrics.errors_by_type.rate_limit++;
            this.writeLog('debug', {
                recipient,
                event: 'banned',
                burstLimit: (_q = (_p = this.config.rateLimiting) === null || _p === void 0 ? void 0 : _p.burstLimit) !== null && _q !== void 0 ? _q : 5,
                cooldownPeriod: (_s = (_r = this.config.rateLimiting) === null || _r === void 0 ? void 0 : _r.cooldownPeriod) !== null && _s !== void 0 ? _s : 1000,
                message: 'Rate limit exceeded for recipient'
            });
            throw {
                code: 'ERATELIMIT',
                message: 'Rate limit exceeded for recipient',
                details: {
                    type: 'rate_limit_error',
                    context: {
                        recipient,
                        burstLimit: (_u = (_t = this.config.rateLimiting) === null || _t === void 0 ? void 0 : _t.burstLimit) !== null && _u !== void 0 ? _u : 5,
                        cooldownPeriod: (_w = (_v = this.config.rateLimiting) === null || _v === void 0 ? void 0 : _v.cooldownPeriod) !== null && _w !== void 0 ? _w : 1000
                    },
                    timestamp: new Date().toISOString()
                }
            };
        }
        recipientLimits.count++;
    }
    async createConnection() {
        return new Promise((resolve, reject) => {
            const socket = new net.Socket();
            socket.setTimeout(this.config.timeout);
            socket.on('timeout', () => {
                socket.destroy();
                this.metrics.connection_errors++;
                this.metrics.last_email_status = 'failure';
                this.metrics.errors_by_type.timeout++;
                reject({
                    code: 'ETIMEDOUT',
                    message: 'Connection timeout',
                    details: {
                        type: 'connection_error',
                        context: {
                            host: this.config.host,
                            port: this.config.port,
                            timeout: this.config.timeout
                        },
                        timestamp: new Date().toISOString()
                    }
                });
            });
            socket.connect({
                host: this.config.host,
                port: this.config.port
            }, async () => {
                this.metrics.active_connections++;
                if (this.config.secure) {
                    const tlsSocket = new tls.TLSSocket(socket, {
                        rejectUnauthorized: true,
                        minVersion: 'TLSv1.2',
                        maxVersion: 'TLSv1.3',
                        ciphers: 'TLS_AES_128_GCM_SHA256:TLS_AES_256_GCM_SHA384:TLS_CHACHA20_POLY1305_SHA256',
                        honorCipherOrder: true
                    });
                    resolve(tlsSocket);
                }
                else {
                    resolve(socket);
                }
            });
            socket.on('error', (err) => {
                this.metrics.connection_errors++;
                this.metrics.last_email_status = 'failure';
                this.metrics.errors_by_type.connection++;
                reject({
                    code: err.code || 'ECONNECTION',
                    message: err.message,
                    details: {
                        type: 'connection_error',
                        context: {
                            host: this.config.host,
                            port: this.config.port,
                            originalError: err
                        },
                        timestamp: new Date().toISOString()
                    }
                });
            });
        });
    }
    async sendCommand(socket, command) {
        return new Promise((resolve, reject) => {
            const responseHandler = (data) => {
                const response = data.toString();
                socket.removeListener('data', responseHandler);
                resolve(response);
            };
            socket.on('data', responseHandler);
            socket.write(command + '\r\n', (err) => {
                if (err) {
                    socket.removeListener('data', responseHandler);
                    this.metrics.last_email_status = 'failure';
                    this.metrics.errors_by_type.command++;
                    reject({
                        code: 'ECOMMAND',
                        message: 'Failed to send command',
                        details: {
                            type: 'command_error',
                            context: {
                                command: command.substring(0, 20) + '...',
                                error: err
                            },
                            timestamp: new Date().toISOString()
                        }
                    });
                }
            });
        });
    }
    generateBoundary() {
        return '----' + crypto__namespace.randomBytes(16).toString('hex');
    }
    sanitizeHeader(value) {
        // Remove newlines and other potentially dangerous characters
        return value.replace(/[\r\n\t\v\f]/g, '');
    }
    sanitizePath(filePath) {
        var _a;
        try {
            // Normalize the path to handle different path formats
            const normalizedPath = path__namespace.normalize(filePath);
            // Get the absolute path, using process.cwd() as base if path is relative
            const absolutePath = path__namespace.isAbsolute(normalizedPath)
                ? normalizedPath
                : path__namespace.join(process.cwd(), normalizedPath);
            // For debugging
            if (((_a = this.config.logging) === null || _a === void 0 ? void 0 : _a.level) === "debug") {
                console.log('Path details:', {
                    original: filePath,
                    normalized: normalizedPath,
                    absolute: absolutePath,
                    exists: fs__namespace.existsSync(absolutePath),
                    cwd: process.cwd()
                });
            }
            // Verify the file exists
            if (!fs__namespace.existsSync(absolutePath)) {
                throw new Error(`File does not exist: ${filePath}`);
            }
            // Verify file is readable
            try {
                fs__namespace.accessSync(absolutePath, fs__namespace.constants.R_OK);
            }
            catch (err) {
                throw new Error(`File is not readable: ${filePath}`);
            }
            return absolutePath;
        }
        catch (err) {
            throw new Error(`Path validation failed: ${err === null || err === void 0 ? void 0 : err.message}`);
        }
    }
    buildMimeMessage(options, boundary) {
        let message = '';
        // Headers
        message += 'MIME-Version: 1.0\r\n';
        message += `From: ${this.sanitizeHeader(this.config.from)}\r\n`;
        message += `To: ${this.sanitizeHeader(Array.isArray(options.to) ? options.to.join(', ') : options.to)}\r\n`;
        if (options.cc) {
            message += `Cc: ${Array.isArray(options.cc) ? options.cc.join(', ') : options.cc}\r\n`;
        }
        message += `Subject: ${this.sanitizeHeader(options.subject)}\r\n`;
        message += `Content-Type: multipart/mixed; boundary="${boundary}"\r\n\r\n`;
        // Text/HTML Content
        if (options.text) {
            message += `--${boundary}\r\n`;
            message += 'Content-Type: text/plain; charset=utf-8\r\n\r\n';
            message += options.text + '\r\n\r\n';
        }
        if (options.html) {
            message += `--${boundary}\r\n`;
            message += 'Content-Type: text/html; charset=utf-8\r\n\r\n';
            message += options.html + '\r\n\r\n';
        }
        // Attachments
        if (options.attachments) {
            for (const attachment of options.attachments) {
                let content;
                let filename;
                if (attachment.path) {
                    try {
                        const filePath = this.sanitizePath(attachment.path);
                        content = fs__namespace.readFileSync(filePath);
                        console.log("filePath", filePath);
                        if (!attachment.filename) {
                            filename = path__namespace.basename(filePath);
                        }
                        else {
                            const fileExt = path__namespace.extname(filePath);
                            filename = path__namespace.extname(attachment.filename) ? attachment.filename : attachment.filename + fileExt;
                        }
                    }
                    catch (err) {
                        this.metrics.last_email_status = 'failure';
                        this.metrics.errors_by_type.attachment++;
                        throw {
                            code: 'EATTACHMENT',
                            message: 'Failed to read attachment file',
                            details: {
                                type: 'attachment_error',
                                context: {
                                    path: attachment.path,
                                    error: err
                                },
                                timestamp: new Date().toISOString()
                            }
                        };
                    }
                }
                else if (attachment.content) {
                    content = Buffer.isBuffer(attachment.content) ?
                        attachment.content :
                        Buffer.from(attachment.content);
                    filename = attachment.filename || 'attachment';
                }
                else {
                    continue;
                }
                const contentType = attachment.contentType || this.detectMimeType(filename);
                message += `--${boundary}\r\n`;
                message += `Content-Type: ${contentType}\r\n`;
                message += `Content-Disposition: attachment; filename="${filename}"\r\n`;
                message += `Content-Transfer-Encoding: ${attachment.encoding || 'base64'}\r\n\r\n`;
                message += content.toString('base64') + '\r\n\r\n';
            }
        }
        message += `--${boundary}--\r\n.`;
        return message;
    }
    detectMimeType(filename) {
        const ext = path__namespace.extname(filename).toLowerCase();
        const mimeTypesList = mimeTypes;
        return mimeTypesList[ext] || 'application/octet-stream';
    }
    shouldLog(level) {
        var _a;
        const configLevel = ((_a = this.config.logging) === null || _a === void 0 ? void 0 : _a.level) || 'info';
        // If config level is debug, log everything
        if (configLevel === 'debug') {
            return true;
        }
        // For other levels, only log matching or higher priority events
        switch (configLevel) {
            case 'info':
                return level === 'info'; // Only log successful events
            case 'warn':
                return level === 'warn'; // Only log warnings
            case 'error':
                return level === 'error'; // Only log errors
            default:
                return false;
        }
    }
    maskSensitiveData(data) {
        if (!data)
            return data;
        const sensitiveFields = ['password', 'auth', 'token', 'key'];
        const masked = { ...data };
        for (const field of sensitiveFields) {
            if (masked[field]) {
                masked[field] = '********';
            }
        }
        return masked;
    }
    writeLog(level, data) {
        var _a, _b;
        // First check if we should log this message
        if (!this.shouldLog(level)) {
            return;
        }
        try {
            // Mask sensitive data
            const maskedData = this.maskSensitiveData(data);
            const logEntry = {
                timestamp: new Date().toISOString(),
                level,
                ...maskedData
            };
            // Add custom fields if configured
            if ((_a = this.config.logging) === null || _a === void 0 ? void 0 : _a.customFields) {
                for (const field of this.config.logging.customFields) {
                    if (data[field]) {
                        logEntry[field] = data[field];
                    }
                }
            }
            // Format the log entry
            let formattedLog;
            if (((_b = this.config.logging) === null || _b === void 0 ? void 0 : _b.format) === 'text') {
                formattedLog = `[${logEntry.timestamp}] ${level.toUpperCase()}: ${JSON.stringify(maskedData)}\n`;
            }
            else {
                formattedLog = JSON.stringify(logEntry) + '\n';
            }
            // Write to file if destination exists, otherwise write to console
            if (this.logFilePath) {
                fs__namespace.appendFileSync(this.logFilePath, formattedLog);
            }
            else {
                // Use appropriate console method based on level
                switch (level) {
                    case 'error':
                        console.error(formattedLog);
                        break;
                    case 'warn':
                        console.warn(formattedLog);
                        break;
                    case 'debug':
                        console.debug(formattedLog);
                        break;
                    default:
                        console.log(formattedLog);
                }
            }
        }
        catch (error) {
            console.warn('Failed to write log:', error);
        }
    }
    async sendMail(options) {
        var _a, _b, _c, _d, _e, _f;
        // Debug level logging
        this.writeLog('debug', {
            event: 'mail_attempt',
            recipients: options.to,
            subject: options.subject,
            timestamp: new Date().toISOString()
        });
        // First verify connection before proceeding
        if (!await this.verifyConnection()) {
            this.metrics.last_email_status = 'failure';
            this.metrics.errors_by_type.connection++;
            throw {
                code: 'ECONNECTION',
                message: 'SMTP connection failed, cannot send email',
                details: {
                    type: 'connection_error',
                    context: {
                        host: this.config.host,
                        port: this.config.port
                    },
                    timestamp: new Date().toISOString()
                }
            };
        }
        const recipients = [
            ...(Array.isArray(options.to) ? options.to : [options.to]),
            ...(options.cc ? (Array.isArray(options.cc) ? options.cc : [options.cc]) : []),
            ...(options.bcc ? (Array.isArray(options.bcc) ? options.bcc : [options.bcc]) : [])
        ];
        // Validate email format for all recipients
        for (const recipient of recipients) {
            if (!this.validateEmail(recipient)) {
                this.metrics.last_email_status = 'failure';
                this.metrics.errors_by_type.validation++;
                throw {
                    code: 'EINVALIDEMAIL',
                    message: `Invalid email format: ${recipient}`,
                    details: {
                        type: 'validation_error',
                        context: {
                            recipient
                        },
                        timestamp: new Date().toISOString()
                    }
                };
            }
        }
        // Check rate limits for each recipient if enabled
        if ((_a = this.config.rateLimiting) === null || _a === void 0 ? void 0 : _a.perRecipient) {
            for (const recipient of recipients) {
                this.checkRateLimit(recipient);
            }
        }
        const startTime = Date.now();
        let socket;
        let currentCommand = '';
        try {
            socket = await this.createConnection();
            currentCommand = 'EHLO';
            await this.sendCommand(socket, `EHLO ${this.config.host}`);
            if (!this.config.secure) {
                currentCommand = 'STARTTLS';
                await this.sendCommand(socket, 'STARTTLS');
                const tlsSocket = new tls.TLSSocket(socket, {
                    rejectUnauthorized: true,
                    minVersion: 'TLSv1.2',
                    maxVersion: 'TLSv1.3',
                    ciphers: 'TLS_AES_128_GCM_SHA256:TLS_AES_256_GCM_SHA384:TLS_CHACHA20_POLY1305_SHA256',
                    honorCipherOrder: true
                });
            }
            currentCommand = 'AUTH';
            await this.sendCommand(socket, `AUTH LOGIN`);
            await this.sendCommand(socket, Buffer.from(this.config.auth.user).toString('base64'));
            await this.sendCommand(socket, Buffer.from(this.config.auth.pass).toString('base64'));
            currentCommand = 'MAIL FROM';
            await this.sendCommand(socket, `MAIL FROM:<${this.config.from}>`);
            currentCommand = 'RCPT TO';
            for (const recipient of recipients) {
                await this.sendCommand(socket, `RCPT TO:<${recipient}>`);
            }
            currentCommand = 'DATA';
            await this.sendCommand(socket, 'DATA');
            const boundary = this.generateBoundary();
            const mimeMessage = this.buildMimeMessage(options, boundary);
            await this.sendCommand(socket, mimeMessage);
            const messageId = crypto__namespace.randomBytes(16).toString('hex');
            const sendTime = Date.now() - startTime;
            // Reset consecutive failures on success
            if ((_b = this.config.rateLimiting) === null || _b === void 0 ? void 0 : _b.perRecipient) {
                for (const recipient of recipients) {
                    const limits = this.rateLimits.get(recipient);
                    if (limits) {
                        limits.consecutiveFailures = 0;
                    }
                }
            }
            this.updateMetrics(true, sendTime);
            // Info level logging for success
            this.writeLog('info', {
                success: true,
                event: 'mail_success',
                messageId,
                recipients: options.to,
                subject: options.subject,
                sendTime
            });
            return {
                success: true,
                messageId,
                timestamp: new Date(),
                recipients: recipients.join(', '),
            };
        }
        catch (error) {
            // Store failed email details in metrics with enhanced tracking
            const failureDetails = {
                timestamp: new Date(),
                recipient: recipients.join(', '),
                subject: options.subject,
                error: {
                    code: error.code,
                    message: error.message,
                    details: error.details
                },
                command: currentCommand,
                attempt: 1
            };
            this.metrics.failed_emails.push(failureDetails);
            this.metrics.failure_details.last_error = failureDetails;
            // Update per-recipient error counts
            for (const recipient of recipients) {
                const currentCount = this.metrics.failure_details.error_count_by_recipient.get(recipient) || 0;
                this.metrics.failure_details.error_count_by_recipient.set(recipient, currentCount + 1);
            }
            // Calculate average failures per recipient
            const totalRecipients = this.metrics.failure_details.error_count_by_recipient.size;
            const totalFailures = Array.from(this.metrics.failure_details.error_count_by_recipient.values())
                .reduce((sum, count) => sum + count, 0);
            this.metrics.failure_details.avg_failures_per_recipient = totalRecipients ? totalFailures / totalRecipients : 0;
            // Update consecutive failures
            if ((_c = this.config.rateLimiting) === null || _c === void 0 ? void 0 : _c.perRecipient) {
                for (const recipient of recipients) {
                    const limits = this.rateLimits.get(recipient);
                    if (limits) {
                        limits.consecutiveFailures++;
                        limits.lastFailure = Date.now();
                    }
                }
            }
            const sendTime = Date.now() - startTime;
            this.updateMetrics(false, sendTime);
            this.metrics.last_email_status = 'failure';
            this.metrics.consecutive_failures++;
            this.metrics.last_error_timestamp = Date.now();
            // Update error type metrics
            if ((_d = error.details) === null || _d === void 0 ? void 0 : _d.type) {
                switch (error.details.type) {
                    case 'connection_error':
                        this.metrics.errors_by_type.connection++;
                        break;
                    case 'authentication_error':
                        this.metrics.errors_by_type.authentication++;
                        break;
                    case 'rate_limit_error':
                        this.metrics.errors_by_type.rate_limit++;
                        break;
                    case 'validation_error':
                        this.metrics.errors_by_type.validation++;
                        break;
                    case 'timeout_error':
                        this.metrics.errors_by_type.timeout++;
                        break;
                    case 'attachment_error':
                        this.metrics.errors_by_type.attachment++;
                        break;
                    case 'command_error':
                        this.metrics.errors_by_type.command++;
                        break;
                    default:
                        this.metrics.errors_by_type.unknown++;
                }
            }
            else {
                this.metrics.errors_by_type.unknown++;
            }
            const errorDetails = {
                code: error.code || 'EUNKNOWN',
                message: error.message || 'An unknown error occurred',
                details: {
                    type: ((_e = error.details) === null || _e === void 0 ? void 0 : _e.type) || 'smtp_error',
                    context: {
                        ...(_f = error.details) === null || _f === void 0 ? void 0 : _f.context,
                        lastCommand: currentCommand,
                        recipients,
                        subject: options.subject,
                        attemptNumber: 1,
                        socketState: socket ? 'connected' : 'disconnected'
                    },
                    timestamp: new Date().toISOString()
                }
            };
            // Error level logging
            this.writeLog('error', {
                success: false,
                event: 'mail_failure',
                error: errorDetails,
                recipients: options.to,
                subject: options.subject,
                sendTime
            });
            throw errorDetails;
        }
        finally {
            if (socket && !this.config.keepAlive) {
                socket.end();
                this.metrics.active_connections--;
            }
        }
    }
    updateMetrics(success, sendTime) {
        // Update counters
        this.metrics.emails_total++;
        if (success) {
            this.metrics.emails_successful++;
            this.metrics.last_email_status = 'success';
            this.metrics.consecutive_failures = 0;
        }
        else {
            this.metrics.emails_failed++;
            this.metrics.last_email_status = 'failure';
        }
        // Update timing metrics
        const sendTimeSeconds = sendTime / 1000;
        this.metrics.email_send_duration_seconds.count++;
        this.metrics.email_send_duration_seconds.sum += sendTimeSeconds;
        this.metrics.email_send_duration_seconds.avg =
            this.metrics.email_send_duration_seconds.sum / this.metrics.email_send_duration_seconds.count;
        this.metrics.email_send_duration_seconds.max =
            Math.max(this.metrics.email_send_duration_seconds.max, sendTimeSeconds);
        this.metrics.email_send_duration_seconds.min =
            Math.min(this.metrics.email_send_duration_seconds.min, sendTimeSeconds);
        // Update histogram buckets
        Object.keys(this.metrics.email_send_duration_seconds.buckets).forEach(bucket => {
            if (sendTimeSeconds <= parseFloat(bucket)) {
                this.metrics.email_send_duration_seconds.buckets[bucket]++;
            }
        });
        // Update rate metrics
        const now = Date.now();
        const timeWindow = 60000; // 1 minute
        this.metrics.email_send_rate = this.metrics.emails_total / ((now - this.metrics.last_email_timestamp) / timeWindow);
        this.metrics.last_email_timestamp = now;
    }
    getMetrics() {
        return { ...this.metrics };
    }
    async verifyConnection() {
        try {
            const socket = await this.createConnection();
            socket.end();
            return true;
        }
        catch (_a) {
            this.metrics.last_email_status = 'failure';
            this.metrics.errors_by_type.connection++;
            return false;
        }
    }
}

const mimeTypes = {
    // Application Types
    '.aac': 'audio/aac',
    '.abw': 'application/x-abiword',
    '.arc': 'application/x-freearc',
    '.azw': 'application/vnd.amazon.ebook',
    '.bin': 'application/octet-stream',
    '.bz': 'application/x-bzip',
    '.bz2': 'application/x-bzip2',
    '.cda': 'application/x-cdf',
    '.csh': 'application/x-csh',
    '.doc': 'application/msword',
    '.docx': 'application/vnd.openxmlformats-officedocument.wordprocessingml.document',
    '.eot': 'application/vnd.ms-fontobject',
    '.epub': 'application/epub+zip',
    '.gz': 'application/gzip',
    '.jar': 'application/java-archive',
    '.json': 'application/json',
    '.jsonld': 'application/ld+json',
    '.mpkg': 'application/vnd.apple.installer+xml',
    '.odp': 'application/vnd.oasis.opendocument.presentation',
    '.ods': 'application/vnd.oasis.opendocument.spreadsheet',
    '.odt': 'application/vnd.oasis.opendocument.text',
    '.ogx': 'application/ogg',
    '.pdf': 'application/pdf',
    '.php': 'application/x-httpd-php',
    '.ppt': 'application/vnd.ms-powerpoint',
    '.pptx': 'application/vnd.openxmlformats-officedocument.presentationml.presentation',
    '.rar': 'application/vnd.rar',
    '.rtf': 'application/rtf',
    '.sh': 'application/x-sh',
    '.tar': 'application/x-tar',
    '.vsd': 'application/vnd.visio',
    '.xhtml': 'application/xhtml+xml',
    '.xls': 'application/vnd.ms-excel',
    '.xlsx': 'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet',
    '.xml': 'application/xml',
    '.xul': 'application/vnd.mozilla.xul+xml',
    '.zip': 'application/zip',
    '.7z': 'application/x-7z-compressed',
    // Audio Types
    '.mid': 'audio/midi',
    '.midi': 'audio/midi',
    '.mp3': 'audio/mpeg',
    '.oga': 'audio/ogg',
    '.opus': 'audio/opus',
    '.wav': 'audio/wav',
    '.weba': 'audio/webm',
    '.3gp': 'audio/3gpp',
    '.3g2': 'audio/3gpp2',
    // Image Types
    '.apng': 'image/apng',
    '.avif': 'image/avif',
    '.bmp': 'image/bmp',
    '.gif': 'image/gif',
    '.ico': 'image/vnd.microsoft.icon',
    '.jpeg': 'image/jpeg',
    '.jpg': 'image/jpeg',
    '.png': 'image/png',
    '.svg': 'image/svg+xml',
    '.tif': 'image/tiff',
    '.tiff': 'image/tiff',
    '.webp': 'image/webp',
    // Text Types
    '.css': 'text/css',
    '.csv': 'text/csv',
    '.htm': 'text/html',
    '.html': 'text/html',
    '.ics': 'text/calendar',
    '.js': 'text/javascript',
    '.mjs': 'text/javascript',
    '.txt': 'text/plain',
    // Video Types
    '.avi': 'video/x-msvideo',
    '.mp4': 'video/mp4',
    '.mpeg': 'video/mpeg',
    '.ogv': 'video/ogg',
    '.ts': 'video/mp2t',
    '.webm': 'video/webm',
    '.wmv': 'video/x-ms-wmv',
    // Font Types
    '.otf': 'font/otf',
    '.ttf': 'font/ttf',
    '.woff': 'font/woff',
    '.woff2': 'font/woff2',
    // Model Types
    '.gltf': 'model/gltf+json',
    '.glb': 'model/gltf-binary',
    '.obj': 'model/obj',
    '.stl': 'model/stl',
    '.usdz': 'model/vnd.usdz+zip',
    // Chemical and Scientific Types
    '.cif': 'chemical/x-cif',
    '.mol': 'chemical/x-mdl-molfile',
    '.pdb': 'chemical/x-pdb',
    '.xyz': 'chemical/x-xyz',
    // CAD and Technical Types
    '.dwg': 'image/vnd.dwg',
    '.dxf': 'image/vnd.dxf',
    '.step': 'application/step',
    '.stp': 'application/step',
    '.iges': 'model/iges',
    '.igs': 'model/iges',
    // Database Types
    '.mdb': 'application/x-msaccess',
    '.sql': 'application/sql',
    '.sqlite': 'application/x-sqlite3',
    '.db': 'application/x-sqlite3',
    // Vector Graphics
    '.ai': 'application/postscript',
    '.eps': 'application/postscript',
    '.ps': 'application/postscript',
    // E-book Formats
    '.mobi': 'application/x-mobipocket-ebook',
    '.azw3': 'application/vnd.amazon.ebook',
    // Certificate and Security Types
    '.cer': 'application/x-x509-ca-cert',
    '.crt': 'application/x-x509-ca-cert',
    '.der': 'application/x-x509-ca-cert',
    '.p7b': 'application/x-pkcs7-certificates',
    '.p7c': 'application/x-pkcs7-mime',
    '.p7m': 'application/x-pkcs7-mime',
    '.p7s': 'application/x-pkcs7-signature',
    '.pem': 'application/x-pem-file',
    // Configuration and System Files
    '.cfg': 'text/plain',
    '.conf': 'text/plain',
    '.ini': 'text/plain',
    '.log': 'text/plain',
    '.prop': 'text/plain',
    '.properties': 'text/plain',
    '.yaml': 'text/yaml',
    '.yml': 'text/yaml',
    '.toml': 'text/plain',
    // Source Code Files
    '.c': 'text/x-c',
    '.cpp': 'text/x-c++',
    '.cs': 'text/x-csharp',
    '.go': 'text/x-go',
    '.java': 'text/x-java-source',
    '.py': 'text/x-python',
    '.rb': 'text/x-ruby',
    '.rs': 'text/x-rust',
    '.swift': 'text/x-swift',
    '.tsx': 'text/typescript-jsx',
    '.jsx': 'text/jsx'
};

exports.FastMailer = FastMailer;
exports.mimeTypes = mimeTypes;
//# sourceMappingURL=index.js.map
